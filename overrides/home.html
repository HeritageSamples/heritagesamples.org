{% extends "main.html" %}

{% block styles %}
  {{ super() }}
  <style>
    /* Make header static, hide sidebars/content for clean hero */
    .md-header { position: initial; }
    .md-main__inner { margin: 0; }
    .md-content { display: none; }

    /* Hide sidebars completely */
    @media screen and (min-width: 60em) {
      .md-sidebar--secondary { display: none !important; }
    }
    @media screen and (min-width: 76.25em) {
      .md-sidebar--primary { display: none !important; }
    }

    /* Hero styling */
    .mdx-hero {
      min-height: 80vh;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 2rem;
  align-items: flex-start;
  padding-top: 3rem;
    }

    .mdx-hero__content h1 {
      font-size: 3.5rem;
      margin-bottom: 1rem;
      color: var(--md-primary-fg-color);
    }

    .mdx-hero__content p {
      font-size: 1.25rem;
      max-width: 80vw;
      margin: 0 auto 1.25rem;
      opacity: 0.9;
    }

    /* Rotating banner */
    .hs-banner {
      position: relative;
      width: 100%;
      max-width: 1100px;
      height: clamp(220px, 32vw, 420px);
      margin: 1.25rem auto 1.75rem;
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 10px 28px rgba(0,0,0,.18);
      background: rgba(0,0,0,.06);
    }

    .hs-banner__layer {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      opacity: 0;
      transition: opacity 1.2s ease-in-out;
      will-change: opacity;
    }
    .hs-banner__layer.is-visible { opacity: 1; }

    .hs-banner__caption {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: .75rem 1rem;
      font-size: .95rem;
      line-height: 1.25rem;
      text-align: left;
      color: #fff;
      background: linear-gradient(to top, rgba(0,0,0,.62), rgba(0,0,0,0));
      text-shadow: 0 2px 10px rgba(0,0,0,.45);
    }

.hs-hero {
  width: 100%;
  max-width: 1100px;   /* matches banner */
  margin: 0 auto;
  text-align: left;    /* key change */
}

/* Title + logo */
.hs-title {
  display: flex;
  gap: 1rem;
  align-items: center;
  justify-content: center; /* overall block centred */
  margin-bottom: 1rem;
}

.hs-logo {
  width: 64px;
  height: 64px;
  object-fit: contain;
}

.hs-title-text h1 {
  margin: 0;
  line-height: 1.05;
}

.hs-tagline {
  margin: .35rem 0 0;
  font-size: 1.15rem;
  opacity: .9;
  max-width: 70ch;
}

/* Copy column */
.hs-copy {
  max-width: 90ch;
  margin: 0 auto;     /* centred column */
}

.hs-copy p {
  font-size: 1.1rem;
  line-height: 1.6;
  margin: 0 0 1rem;
}

    /* Optional: keep buttons nicely spaced on small screens */
    .hs-button-row {
      display: flex;
      gap: .75rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 1.25rem;
    }

.hs-button--ghost {
  background: transparent !important;
  border: 1px solid currentColor;
}

/* Mobile stacking */
@media (max-width: 700px) {
  .hs-title {
    flex-direction: column;
    text-align: center;
  }
  .hs-hero {
    text-align: center;
  }
  .hs-copy {
    text-align: left; /* keep paragraphs readable even on mobile */
  }
  
  /* Logo sizing */
.hs-logo{
  width: 64px;
  height: 64px;
  object-fit: contain;
  flex: 0 0 auto;
}

/* Default: show the black logo, hide the white logo */
.hs-logo--dark { display: none; }
.hs-logo--light { display: block; }

/* When Material is in dark mode ("slate" is the usual name), swap */
html[data-md-color-scheme="slate"] .hs-logo--light { display: none; }
html[data-md-color-scheme="slate"] .hs-logo--dark  { display: block; }

/* Tagline: bold and same colour as the H1 */
.hs-tagline{
  margin: .35rem 0 0;
  font-weight: 700;
  color: var(--md-primary-fg-color);
  font-size: 1.15rem;
  opacity: 1;         /* don’t fade if you want it to match the H1 strongly */
  max-width: 70ch;
}

/* H1 colour already uses --md-primary-fg-color in your CSS; keep it consistent */
.mdx-hero__content h1{
  color: var(--md-primary-fg-color);
}

  </style>
{% endblock %}

{% block tabs %}
  {{ super() }}

  <section class="mdx-container">
    <div class="md-grid md-typeset">
      <div class="mdx-hero">
  <div class="mdx-hero__content hs-hero">

    <!-- Title row: logo + H1 -->
    <div class="hs-title">
  <img class="hs-logo hs-logo--light" src="{{ 'images/hs-logo.svg' | url }}" alt="Heritage Samples Registry logo" />
  <img class="hs-logo hs-logo--dark"  src="{{ 'images/hs-logo-light.svg' | url }}" alt="Heritage Samples Registry logo" />

  <div class="hs-title-text">
    <h1>Heritage Samples Registry</h1>
    <p class="hs-tagline">Persistent identification, discovery, and sharing of heritage samples in heritage science.</p>
  </div>
</div>

    <!-- Banner -->
    <div class="hs-banner" id="hsBanner"
         data-banner-dir="{{ 'images/banner/' | url }}"
         data-captions-url="{{ 'images/banner/captions.csv' | url }}"
         data-interval-ms="9000"
         data-fade-ms="1200">
      <div class="hs-banner__layer is-visible" id="hsBannerA"></div>
      <div class="hs-banner__layer" id="hsBannerB"></div>
      <div class="hs-banner__caption" id="hsBannerCaption">Loading…</div>
    </div>

    <!-- Body copy in a readable column -->
    <div class="hs-copy">
      <p>
        The <b>Heritage Samples Registry</b> is an emerging international initiative to support the persistent
        identification, discovery, and sharing of information about material samples in the context of heritage
        science. These samples, including paint cross-sections, material fragments, reference standards, and other
        physical specimens, are valuable research assets that underpin heritage science, conservation, and more
        general research worldwide.
      </p>

      <p>
        The Registry aims to make the existence of these samples <b>findable, citable, and consistently documented</b>,
        enabling researchers and institutions to connect local sample records with global research outputs.
      </p>
    </div>

    <!-- CTAs -->
    <div class="hs-button-row">
      <a href="welcome" class="md-button md-button--primary">Learn More</a>
      <a href="https://github.com/HeritageSamples/heritagesamples.org/issues" class="md-button">Get Involved</a>
      <!-- Optional extras (demoted) -->
      <a href="registry" class="md-button hs-button--ghost">Search Registry</a>
      <a href="docs" class="md-button hs-button--ghost">Documentation</a>
    </div>

    <!-- If you need more than ~4 actions, switch to quick links -->
    <!--
    <p class="hs-quicklinks">
      Quick links:
      <a href="registry">Search</a> ·
      <a href="schemas">Schemas</a> ·
      <a href="partners">Partners</a> ·
      <a href="contact">Contact</a>
    </p>
    -->

  </div>
</div>

    </div>
  </section>

  <script>
    (function () {
      const banner = document.getElementById("hsBanner");
      if (!banner) return;

      const layerA = document.getElementById("hsBannerA");
      const layerB = document.getElementById("hsBannerB");
      const captionEl = document.getElementById("hsBannerCaption");

      const bannerDir = banner.getAttribute("data-banner-dir") || "";
      const captionsUrl = banner.getAttribute("data-captions-url") || "";
      const intervalMs = parseInt(banner.getAttribute("data-interval-ms") || "9000", 10);
      const fadeMs = parseInt(banner.getAttribute("data-fade-ms") || "1200", 10);

      // Make the JS transition duration match data-fade-ms
      layerA.style.transitionDuration = (fadeMs / 1000) + "s";
      layerB.style.transitionDuration = (fadeMs / 1000) + "s";

      let items = []; // { filename, caption }
      let currentIndex = -1;
      let showingA = true;
      let timer = null;

      function normaliseLine(line) {
        return (line || "").replace(/\r/g, "").trim();
      }

      function parseCaptions(text) {
        const lines = text.split("\n").map(normaliseLine).filter(Boolean);

        const out = [];
        for (const line of lines) {
          // Ignore comment lines like "//..." or "#..."
          if (line.startsWith("//") || line.startsWith("#")) continue;

          // You said "TAB" — but allow any whitespace run as a separator
          // (so "filename<tab>caption" or "filename  caption" both work)
          const parts = line.split(/\t+|\s{2,}/); // tabs OR 2+ spaces
          if (parts.length < 2) continue;

          const filename = parts.shift().trim();
          const caption = parts.join(" ").trim();

          if (!filename) continue;
          out.push({ filename, caption });
        }
        return out;
      }

      function pickNextIndex() {
        if (items.length === 0) return -1;
        if (items.length === 1) return 0;

        let next = currentIndex;
        // avoid immediate repeats
        while (next === currentIndex) {
          next = Math.floor(Math.random() * items.length);
        }
        return next;
      }

      function preloadImage(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(true);
          img.onerror = () => reject(new Error("Failed to load " + url));
          img.src = url;
        });
      }

      async function showIndex(nextIndex) {
        if (nextIndex < 0 || nextIndex >= items.length) return;

        const { filename, caption } = items[nextIndex];
        const imgUrl = bannerDir + filename;

        try {
          await preloadImage(imgUrl);
        } catch (e) {
          // If an image is missing, skip it and try another
          console.warn(e);
          return;
        }

        const incoming = showingA ? layerB : layerA;
        const outgoing = showingA ? layerA : layerB;

        incoming.style.backgroundImage = `url("${imgUrl}")`;
        captionEl.textContent = caption || "";

        incoming.classList.add("is-visible");
        outgoing.classList.remove("is-visible");

        showingA = !showingA;
        currentIndex = nextIndex;
      }

      function startRotation() {
        if (timer) clearInterval(timer);
        timer = setInterval(async () => {
          const nextIndex = pickNextIndex();
          await showIndex(nextIndex);
        }, intervalMs);
      }

      async function init() {
        if (!captionsUrl) {
          captionEl.textContent = "Banner captions URL not set.";
          return;
        }

        try {
          const res = await fetch(captionsUrl, { cache: "no-store" });
          if (!res.ok) throw new Error("HTTP " + res.status + " fetching captions file");
          const text = await res.text();

          items = parseCaptions(text);

          if (!items.length) {
            captionEl.textContent = "No banner images found in captions file.";
            return;
          }

          // Start with a random image
          const first = Math.floor(Math.random() * items.length);
          await showIndex(first);
          startRotation();

        } catch (e) {
          console.error(e);
          captionEl.textContent = "Failed to load banner captions.";
        }
      }

      // Material for MkDocs uses instant navigation; re-init after navigation events too.
      // This avoids “works on first load but not after clicking”.
      const initOncePerPage = () => init();
      document.addEventListener("DOMContentLoaded", initOncePerPage);
      document.addEventListener("navigation:load", initOncePerPage);
    })();
  </script>
{% endblock %}

{% block content %}{% endblock %}
{% block footer %}{% endblock %}
